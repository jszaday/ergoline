package examples;

import ergoline::_;
import ck;

/* Written with insights from:
 * https://www.appentra.com/parallel-computation-pi/ */

@main class main {
    val numSteps: int;
    var checkIns: int;
    var runningSum: double;

    @entry def main(args: array<string>) {
        numSteps = args.size() > 1 ? args[1].toInt() : 16;
        runningSum = 0.0;
        val numPes: int = ck::numPes();
        if (numSteps < (numPes * 4)) {
            numSteps = numPes * 4;
        }
        if (numSteps % numPes != 0) {
            println("expected an evenly divisible number of steps.");
            exit();
        }
        println(`running ${numSteps} steps of pi computation on ${numPes} PEs`);
        new pi@array1d(numPes, self@, numSteps / numPes);
    }

    @entry def checkIn(partialSum : double) {
        checkIns += 1;
        runningSum += partialSum;

        if (checkIns >= ck::numPes()) {
            println(`result = ${runningSum / numSteps}`);
            exit();
        }
    }
}

class pi {
    val stepsPerPe: int;
    val numSteps: int;

    def step(): double {
        return 1.0 / (numSteps.toDouble());
    }

    @entry def pi(mainProxy: main@, =stepsPerPe: int) {
        numSteps = stepsPerPe * ck::numPes();

        val idx = self[@]index();
        val start = idx * stepsPerPe;
        val end = (idx + 1) * stepsPerPe;
        val s = step();

        var sum: double = 0.0;
        for (var i: int = start; i < end; i += 1) {
            val x: double = (i.toDouble() + 0.5) * s;
            sum += 4.0 / (1.0 + x * x);
        }

        mainProxy.checkIn(sum);
    }
}
