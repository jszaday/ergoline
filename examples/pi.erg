package examples;

import ergoline::_;
import ck;

/* Written with insights from:
 * https://www.appentra.com/parallel-computation-pi/ */

@main class main {
    var runningSum: double;
    var checkIns: int;
    val numSteps: int;

    @entry def main(args: array<string>) {
        val numPes = ck::numPes();
        numSteps = args.size() > 1 ? args[1].toInt() : 16;
        runningSum = 0.0;

        if (numSteps < (numPes * 4)) { numSteps = numPes * 4; }

        if (numSteps % numPes != 0) {
            println("expected an evenly divisible number of steps.");
            exit();
        }

        println("running " + numSteps.toString() +
                " steps of pi computation on " + numPes.toString() + " PEs");

        new pi@array1d(numPes, self@, numSteps / numPes);
    }

    @entry def checkIn(partialSum : double) {
        runningSum += partialSum;
        checkIns += 1;

        if (checkIns >= ck::numPes()) {
            println("result = " + (runningSum / numSteps).toString());
            exit();
        }
    }
}

class pi {
    val stepsPerPe: int;
    val numSteps: int;

    @entry def pi(mainProxy: main@, =stepsPerPe: int) {
        val idx = self[@]index();
        val start = idx * stepsPerPe;
        val end = (idx + 1) * stepsPerPe;
        val s = step();

        numSteps = stepsPerPe * ck::numPes();

        var sum: double = 0.0;
        for (var i: int = start; i < end; i += 1) {
            val x: double = (i.toDouble() + 0.5) * s;
            sum += 4.0 / (1.0 + x * x);
        }

        mainProxy.checkIn(sum);
    }

    def step(): double { return 1.0 / (numSteps.toDouble()); }
}
