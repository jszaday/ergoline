package examples;

import ergoline::_;
import ck;

object globals {
    val north: int = 1;
    val east: int = 2;
    val south: int = 3;
    val west: int = 4;

    var maxIters: int = 100;
    var threshold: double = 0.004;
    var mainProxy: main@;

    var arrDimX: int;
    var arrDimY: int;

    var blockDimX: int;
    var blockDimY: int;
}

@main class main {
    @entry def self(args: array<string>) { self@setup(); }

    @threaded @entry def setup() {
        globals.mainProxy = self@;

        globals.arrDimX = ck::numPes();
        globals.arrDimY = globals.arrDimX;

        ck::updateGlobal<globals>(ck::resumeThread());

        val workers =
            new jacobi2d@array2d(globals.arrDimX, globals.arrDimY);
        
        workers.run();
    }

    @entry def done(numIters: int) {
        if (numIters >= globals.maxIters) {
            println(`main> did not converge, finished ${numIters} iterations.`);
        } else {
            println(`main> converged in ${numIters} iterations.`);
        }

        exit();
    }
}

class jacobi2d {
    val numNeighbors: int = 0;

    val hasEast: bool;
    val hasWest: bool;
    val hasNorth: bool;
    val hasSouth: bool;
    var converged: bool = false;

    val iStart: int = 1;
    val jStart: int = 1;
    val iFinish: int;
    val jFinish: int;

    var prevGrid: array<double, 2>;
    var currGrid: array<double, 2>;

    @entry def self() {
        val shape = (globals.blockDimX + 2, globals.blockDimY + 2);
        prevGrid = array<double, 2>::fill(shape, 0.0);
        currGrid = array<double, 2>::fill(shape, 0.0);

        val (x, y) = self[@]index();
        def inBounds(num: int, max: int): (bool, bool) {
            return (num != 0, num != (max - 1));
        }

        (hasEast, hasWest) = inBounds(x, globals.arrDimX);
        (hasNorth, hasSouth) = inBounds(y, globals.arrDimY);

        numNeighbors = hasEast.toInt() + hasWest.toInt() +
                       hasNorth.toInt() + hasSouth.toInt();

        iStart = (!hasEast).toInt() + 1;
        jStart = (!hasNorth).toInt() + 1;

        iFinish = globals.blockDimX + 1 - (!hasWest).toInt();
        jFinish = globals.blockDimY + 1 - (!hasSouth).toInt();

        enforce_boundaries();
    }

    @threaded @entry def run() {
        var it: int = 0;

        for (; (it < globals.maxIters) && !converged; it += 1) {
            start_iteration(it);

            for (var imsg = 0; imsg < numNeighbors; imsg += 1) {
                when receive_ghost(_ == it, dir, data) => {
                    process_ghost(dir, data);
                }
            }

            converged = (check_and_compute() <= globals.threshold);
            self[@]contribute(converged, bool::logical_and, self@receive_status);

            when receive_status(g_converged) => {
                converged = g_converged;
            }
        }

        match (self[@]index()) {
            case 0, 0 => globals.mainProxy.done(it);
            case _, _ => ;
        }
    }

    @entry def start_iteration(it: int) {
        val (x, y) = self[@]index();
        val (dimX, dimY) = (globals.blockDimX, globals.blockDimY);

        def getColumn(j: int): array<double> {
            val row = new array<double>(dimX);
            for (var i = 0; i < dimX; i += 1) {
                row[i] = currGrid[i + 1, j];
            }
            return row;
        }

        def getRow(i: int): array<double> {
            val col = new array<double>(dimY);
            for (var j = 0; j < dimY; j += 1) {
                col[j] = currGrid[i, j + 1];
            }
            return col;
        }

        if (hasEast) {
            self@[x - 1, y].receive_ghost(it, globals.west, getColumn(1));
        }

        if (hasWest) {
            self@[x + 1, y].receive_ghost(it, globals.east, getColumn(dimY));
        }

        if (hasNorth) {
            self@[x, y - 1].receive_ghost(it, globals.south, getRow(1));
        }

        if (hasSouth) {
            self@[x, y + 1].receive_ghost(it, globals.north, getRow(dimX));
        }
    }

    private def enforce_boundaries() {
        val (dimX, dimY) = (globals.blockDimX, globals.blockDimY);
        val defaultValue = 1.0;

        // set the value of column j in all rows 
        def setColumn(j: int) {
            for (var i = 0; i < (dimX + 2); i += 1) {
                prevGrid[i, j] = defaultValue;
                currGrid[i, j] = defaultValue;
            }
        }

        // set the value of all columns of row i
        def setRow(i: int) {
            for (var j = 0; j < (dimY + 2); j += 1) {
                prevGrid[i, j] = defaultValue;
                currGrid[i, j] = defaultValue;
            }
        }

        if (!hasNorth) setRow(1);

        if (!hasEast) setColumn(1);

        if (!hasSouth) setRow(dimX);

        if (!hasWest) setColumn(dimY);
    }

    private def process_ghost(dir: int, data: array<double>) {
        val (dimX, dimY) = (globals.blockDimX, globals.blockDimY);

        // set the value of column j in all rows 
        def setColumn(j: int) {
            assert(data.size() == dimX);
            for (var i = 0; i < dimX; i += 1) {
                prevGrid[i + 1, j] = data[i];
            }
        }

        // set the value of all columns of row i
        def setRow(i: int) {
            assert(data.size() == dimY);
            for (var j = 0; j < dimY; j += 1) {
                prevGrid[i, j + 1] = data[j];
            }
        }

        if (dir == globals.north && hasNorth) {
            setRow(0);
        } else if (dir == globals.south && hasSouth) {
            setRow(dimX + 1);
        } else if (dir == globals.east && hasEast) {
            setColumn(0);
        } else if (dir == globals.west && hasWest) {
            setColumn(dimY + 1);
        } else {
            abort(`fatal> received unexpected ghost from ${dir}`);
        }
    }

    private def check_and_compute(): double {
        return 0.0;
    }

    @mailbox def receive_ghost(it: int, dir: int, data: array<double>);
    @mailbox def receive_status(g_converged: bool);

}