package examples;

import ergoline::_;
import ck;

def rand(): double {
    // todo implement me!
    return 0.0;
}

@main class cannon {
    var startTime: double;
    var endTime: double;

    @entry def cannon(args: array<string>) {
        val alpha = 1.0;
        val nBlocks = ck::numPes();
        val blockSize = nBlocks * 32;
        val blockShape = (blockSize, blockSize);

        val a = new block@array2d(nBlocks, nBlocks, self@, blockShape, nBlocks, false);
        val b = new block@array2d(nBlocks, nBlocks, self@, blockShape, nBlocks, false);
        val c = new block@array2d(nBlocks, nBlocks, self@, blockShape, nBlocks, false);

        startTime = ck::wallTime();
        a.sendData(c, true);
        b.sendData(c, false);
        c.run(alpha);
    }

    @entry def done() {
        endTime = ck::wallTime();

    }
}

class block {
    val shape: (int, int);
    val nBlocks: int;
    val data: array<double, 2>;
    val mainProxy: cannon@;

    @entry def block(=mainProxy: cannon@, =shape: (int, int),
                     =nBlocks: int, randInit: bool) {
        if (randInit) {
            // TODO add support for tuple expansion~! (*shape)
            data = new array<double, 2>(shape[0], shape[1]);
            for (var i = 0; i < shape[0]; i += 1) {
                for (var j = 0; j < shape[1]; j += 1) {
                    data[i, j] = rand();
                }
            }
        } else {
            data = array<double, 2>::fill(shape, 0.0);
        }
    }

    @mailbox def inputA(block: int, arr: array<double, 2>);
    @mailbox def inputB(block: int, arr: array<double, 2>);

    @entry def sendData(dest: block@array2d, sendA: bool) {
        val idx = self[@]index();

        if (sendA) {
            dest[(idx[0] - idx[1] + nBlocks) % nBlocks, idx[1]].inputA(0, data);
        } else {
            dest[idx[0], (idx[1] - idx[0] + nBlocks) % nBlocks].inputA(0, data);
        }
    }

    @threaded @entry def run(alpha: double) {
        val idx = self[@]index();

        @overlap for (var block = 0; block < nBlocks; block += 1) {
            when inputA(_ == block, blockA: array<double, 2>),
                 inputB(_ == block, blockB: array<double, 2>) => {
                // TODO do dgemm

                if ((block + 1) < nBlocks) {
                    self@[(idx[0] + 1) % nBlocks, idx[1]].inputA(block + 1, blockA);
                    self@[idx[0], (idx[1] + 1) % nBlocks].inputB(block + 1, blockB);
                }
            }
        }

        self[@]contribute(mainProxy.done);
    }
}
