package benchmarks;

import ergoline::_;
import ck;

@main class main {
    val bwProxy: bandwidth@;

    val nIters: int;
    val nReps: int;
    val nSkip: int;
    val arr: array<double, 1>;

    @entry def self(args: array<string>) {
        val nElts = (args.size() > 2) ? args[2].toInt() : 128;
        nIters = (args.size() > 1) ? args[1].toInt() : 256;
        nReps = nIters / 10 + 1;
        nSkip = nReps / 2;
        // create an array filled with the value "0.5"
        arr = array<double, 1>::fill(nElts * 1024, 0.5);
        // ensure it will be auto-xfer'd via zero-copy
        assert(arr.totalSize() >= ck::zcThreshold());
        // pick the most distant PE
        val whichNode = ck::numNodes() - 1;
        val whichPe =
          (whichNode == ck::myNode()) ? ((ck::myPe() + 1) % ck::numPes())
                                      : ck::nodeFirst(whichNode);
        // and create the other chare on it
        bwProxy = new bandwidth@(self@, arr.totalSize(), whichPe);
    }

    @mailbox def continue();

    @threaded @entry def run() {
        var totalTime = 0.0;
        val totalSize = arr.totalSize() / (1024.0 * 1024.0);

        println(`messages are roughly ${totalSize} MB`);

        for (var rep = 0; rep < (nReps + nSkip); rep += 1) {
            val start = ck::wallTime();
            // inform chare that it will receive n messages
            bwProxy.run(nIters);
            // then send the messages
            for (var it = 0; it < nIters; it += 1) {
                // start timing after skipping some iters
                bwProxy.arrival(arr);
            }
            // wait for confirmation from the other chare
            when continue() => ;
            // then stop timing (and accumulate the results)
            val end = ck::wallTime();
            val time = end - start;
            if (rep >= nSkip) {
                totalTime += time;
            }
            println(`info> rep ${rep + 1} out of ${nReps + nSkip} took ${time} s`);
        }

        val avgTime = totalTime / nReps;
        val bw = (totalSize * nIters) / avgTime;

        println(`avg time per iter was ${avgTime * 1000} ms`);
        println(`avg bandwidth was ${bw} MB/s`);

        exit();
    }
}

class bandwidth {
    val mainProxy: main@;
    val buffer: array<char, 1>;

    @entry def self(=mainProxy: main@, size: int) {
        // requires all zc transfers to have manually
        // posted receive buffers (no implicit alloc)
        (self@arrival).requirePost(true);
        buffer = new array<char, 1>(size);
        mainProxy.run();
    }

    @threaded @entry def run(nMsgs: int) {
        // for all n messages (in any order):
        @overlap for (var i = 0; i < nMsgs; i += 1) {
            // manually post a receive buffer
            (self@arrival).post(buffer);
            // then await the message's arrival
            when arrival(_) => ;
        }
        // afterwards, send confirmation to main
        mainProxy.continue();
    }

    @mailbox def arrival(arr: array<double, 1>);
}
